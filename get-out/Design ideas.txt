Design ideas:
This is a document which outlines some general ideas about files and/or classes to use and the expected interface


globals.h

enum class EntityType { Player, Item, Interactable, Room, Exit};

enum class Direction {N, S, E, W};

enum class ActionType {ERROR, QUIT, HELP, LOOK, GO, TAKE, DROP, INSPECT, OPEN, USE, PUT};
std::string getActionPreposition(ActionType actionType);


void log(const std::string& text); // Or something similar to push the output responsability to (use cout).

// Other common helper functions as needed

// END OF GLOBALS.H


class Application
{
	void init(); // Creates the world, whose constructor creates all Entities, itemUses, etc.
	void update(); // Update continuosly gets input, and upon ENTER gives the inputString to the World
	void close(); // Destroys the world, whose constructor must delete all entities, itemUses, etc. and clear vectors
}


class World
{
	std::vector<Entity*> entities;	// This list will be used in the destructor to release all resources
	std::vector<ItemUse*> itemUses;	// This list must also be cleaned up in the destructor
	std::vector<ItemPut*> ItemPuts;	// This list must also be cleaned up in the destructor
	std::vector<InteractableOpen*> interactableOpens; // Clean up again!
	std::vector<ActionEffect*> actionEffects;	// This list must also be cleaned up in the destructor

	// These search methods will return nullptr if search was unsuccessful
	Entity* getEntity(const std::string& name);
	ItemUse* getItemUse(const std::string& item, const std:string& interactable);
	ItemPut* getItemPut(const std::string& item, const std:string& containerItem);
	InteractableOpen* getInteractableOpen(const std::string& interactable)
}


class InputParser
{
	Instruction* parse(const std::string& userInput, const NamesInfo& namesInfo);
	// Calls checkInputValidity first to verify that the words used are contained in the namesInfo object
	// Then calls populateInstruction to obtain Entities from the World

	private:
	bool checkInputValidity (const std::string& userInput, const NamesInfo& namesInfo, Instruction* instruction);
	bool populateInstruction (const std::string& validatedInput, Instruction* instruction);
}


struct Instruction
{	
	actionType actionType;
	union 
	{
		std::string errorDescription
		Direction direction;
		Entity* entity;
		InteractableOpen* interactableOpen;
		ItemUse* itemUse;
		ItemPut* target;
		};
	} data;
	
}


struct InteractableOpen
{
	Interactable* interactable;
	std::string description;
	ActionEffect* effect;
}


struct ItemUse
{
	Item* item;
	Interactable* interactable;
	std::string description;
	ActionEffect* effect;
}


struct ItemPut
{
	Item* item;
	Item* container;
	std::string description;
}


class Effect {
	std::string description;
	virtual doEffect() = 0;
}


struct NamesInfo {
	std::vector<std::string> actionTypes;
	std::vector<std::string> directions;
	std::vector<std::string> items;
	std::vector<std::string> interactables;
}

class Entity
{
	EntityType type;
	std::string name;
	std::string description;
	std::vector<Entity*> children;
}

class Player : Entity
{
	Room* location;
	uint maxItems;

	void executeInstruction(const Instruction* instruction);

	void look();	// Get the description of the room and any elements within
	bool go (Direction direction); // Ask room if there's an exit in that direkol,ction -> Room::getExit
	bool open (Interactable* target); Must check type & presence in room
	bool take (Item* target); // Must check that type == Item && there’s room in children (inheritted from Entity)
	bool drop (Item* target); // Must check that target is in children
	bool inspect (Entity* target);	// Item or interactable
	bool use (ItemUse* itemUse); // Must verify that item can be used in target (done by item internally)
	bool put (ItemPut* itemPut); // 

}

class Item : Entity
{
	Entity* parent;
	std::string detailedDescription;
	bool hasLight;
}

class Interactable : Entity
{
	Room* location;
	std::string detailedDescription;
	bool locked;
	bool visibleInDark;
}

class Room : Entity
{
	bool isDark;
	bool addExit (Exit* newExit);	// Adds an exit (after verifying the entity is an exit) to the list; Used during world creation; Must verify that an exit in that direction doesn't exist already
	Exit* getExit (Direction direction); // Returns an exit, if it exists for that direction
	bool hasItem (Item* item);
	bool hasInteractable (Interactable* interactable);
}

class Exit : Entity
{
	Direction direction;
	bool locked;
	std::string lockDescription;
	Room* sourceRoom;
	Room* targetRoom;
}
